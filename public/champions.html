
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />


    <!-- Open Graph (Discord / Facebook / general link previews) -->
    <meta property="og:title" content="WardUp - Learn League of Legends">
    <meta property="og:description" content="Interactive quizzes, hangman games, and more to master League of Legends champions and items.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://wardup.imthespyke.fr">
    <meta property="og:image" content="https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.18.1/img/champion/centered/Ahri_14.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Optional: Twitter card (Discord also supports it) -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="WardUp - Learn League of Legends">
    <meta name="twitter:description" content="Interactive quizzes, hangman games, and more to master League of Legends champions and items.">
    <meta name="twitter:image" content="https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.18.1/img/champion/centered/Ahri_14.jpg">
    <meta name="twitter:site" content="@imthespyke">

    <!-- Discord color hint (Discord uses theme color sometimes) -->
    <meta name="theme-color" content="#5865F2"> <!-- Discord blurple -->


  <title>WardUp — Guess the Champion</title>
  <style>


    * {
    box-sizing: border-box;
    }
    :root{
      --bg:#0f1221;
      --card:#0f1626;
      --muted:#9aa3bf;
      --accent:#ffe600;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#eaf0ff;font-family:Inter,system-ui,Segoe UI,Arial;display:flex;align-items:center;justify-content:center}
    .wrap{
      width:100%;max-width:740px;padding:28px;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04);
      border-radius:12px;
      padding:24px;
      text-align:center;
      box-shadow:0 12px 36px rgba(0,0,0,0.6);
    }

    .title{ font-weight:700; margin:0 0 10px; font-size:1.1rem; }
    .hintline{ color:var(--muted); font-size:.92rem; margin-bottom:12px; }

    .champ-img{
      width:400px;
      height: 400px;
      border-radius:12px;
      object-fit:contain;
      margin:12px auto;
    }

    .word{
      display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:16px 0;
    }
    .char{
      min-width:26px;
      height:26px;
      display:flex;align-items:center;justify-content:center;border-radius:8px;
      background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);font-weight:700;font-size:18px;letter-spacing:2px;
    }
    .char.space{ background:transparent;border:0; min-width:8px;height:auto; }

    .controls{ display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap; }
    .btn {
      padding:.55rem .85rem;border-radius:10px;border:0;font-weight:700;cursor:pointer;
    }
    .btn-primary{ background:var(--accent); color:#061024; }
    .btn-ghost{ background:transparent;border:1px solid rgba(255,255,255,0.04); color:var(--muted); }
    .btn-danger{ background:#f44336;color:#fff; }

    .input{
      width:100%;max-width:420px;margin:10px auto 0;display:block;padding:.7rem .9rem;border-radius:10px;border:1px solid rgba(255,255,255,0.04);
      background:rgba(255,255,255,0.01);color:inherit;font-size:1rem;
    }

    .status{ margin-top:12px;color:var(--muted);font-size:.95rem;min-height:22px; }

    @media (max-width:520px){
      .champ-img{ width:160px;height:160px; }
      .char{ min-width:16px;height:40px;font-size:16px; }
    }

    /* small shake */
    @keyframes shake { 0%{transform:translateX(0)}25%{transform:translateX(-6px)}50%{transform:translateX(6px)}75%{transform:translateX(-4px)}100%{transform:translateX(0)} }
    .shake { animation:shake .26s linear; }







/* Simple Discord-like toggle */
.toggle {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  user-select: none;
  vertical-align: middle;
}

.toggle input {
  position: absolute;
  opacity: 0;
  pointer-events: none;
}

/* Track */
.toggle .track {
  width: 44px;
  height: 24px;
  border-radius: 999px;
  background: rgba(255,255,255,0.04);
  display: inline-block;
  position: relative;
  transition: background .15s ease, box-shadow .15s ease;
}

/* Knob */
.toggle .knob {
  position: absolute;
  left: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  box-shadow: 0 6px 12px rgba(0,0,0,0.35);
  transition: left .15s cubic-bezier(.2,.9,.3,1);
}

/* Label text */
.toggle .label {
  color: var(--muted, #9aa3bf);
  font-weight: 600;
  font-size: 0.95rem;
}

/* Checked state */
.toggle input:checked + .track {
  background: linear-gradient(90deg, #6b8cff 0%, #8bd6ff 100%);
}
.toggle input:checked + .track .knob {
  left: calc(100% - 4px - 16px);
}

/* Focus ring for keyboard users */
.toggle input:focus + .track {
  box-shadow: 0 0 0 5px rgba(107,140,255,0.12);
}

/* Small screens tweak */
@media (max-width:480px) {
  .toggle .track { width: 36px; height: 20px; }
  .toggle .knob { width: 14px; height: 14px; left: 3px; }
  .toggle input:checked + .track .knob { left: calc(100% - 3px - 14px); }
  .toggle .label { font-size: 0.9rem; }
}



.guess-stats {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  font-family: 'Segoe UI', Roboto, sans-serif;
  flex-wrap: wrap;
  gap: 10px;
}

.percentages {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.guess {
  font-weight: 600;
  padding: 6px 10px;
  border-radius: 6px;
  min-width: 70px;
  text-align: center;
  color: #fff;
  transition: background 0.3s ease;
  font-size: 0.95rem;
}

/* Color gradient for guesses */
.guess_firsttry    { background: #4caf50; }  /* green */
.guess_secondtry   { background: #a3b114; }  /* lime/yellow */
.guess_thirdtry    { background: #e78a00; }  /* orange */
.guess_morethan3   { background: #f44336; }  /* red */
.guess_skipped     { background: #888; }     /* grey */

.total-champs {
  font-weight: 600;
  font-size: 1rem;
  color: #eee;
}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="main" aria-labelledby="title">
      <div id="title" class="title">Guess the Champion</div>
      
      <div class="hintline">Image in the center — type the name and press Guess (or Enter). Use Hint to reveal a letter.</div>

      <div class="controls">
        
        <label class="toggle" for="enableSkins">
            <input id="enableSkins" type="checkbox" />
            <span class="track"><span class="knob"></span></span>
            <span class="label">Enable skins</span>
        </label>
        <label class="toggle" for="onlyUseCentered">
            <input id="onlyUseCentered" type="checkbox" />
            <span class="track"><span class="knob"></span></span>
            <span class="label">Only use centered images</span>
        </label>
        <label class="toggle" for="randomHints">
            <input id="randomHints" type="checkbox" />
            <span class="track"><span class="knob"></span></span>
            <span class="label">Random hints</span>
        </label>
        <button id="clearStats" class="btn btn-sm btn-danger">Clear stats</button>
      </div>
      <img id="champImg" class="champ-img" src="" alt="champion">
      <!-- List of percentages of first try, second, third or more -->
       <div class="guess-stats">
        <div class="percentages">
            <span class="guess guess_firsttry">0% (0)</span>
            <span class="guess guess_secondtry">0% (0)</span>
            <span class="guess guess_thirdtry">0% (0)</span>
            <span class="guess guess_morethan3">0% (0)</span>
            <span class="guess guess_skipped">Skipped: 0</span>
        </div>
        <div class="total-champs">
            Total: <span class="total-count">0</span>
        </div>
      </div>

      <div id="word" class="word" aria-live="polite" aria-atomic="true"></div>

      <input id="input" class="input" placeholder="Type champion name..." autocomplete="off" />

      <div class="controls">
        <button id="hint" class="btn btn-ghost" type="button">Hint</button>
        <button id="guess" class="btn btn-primary" type="button">Guess</button>
        <button id="next" class="btn btn-ghost" type="button">Next</button>
      </div>

      <div id="status" class="status" aria-live="polite"></div>
    </div>
  </div>

  <script>

    console.log("\n\n")
    console.log('%cWardUp!', 'font-size:3em;background: #222; color: #bada55;');
    console.log('%cDesigned by @imthespyke !', 'font-size:1.5em;background: #222; color: #da55ba;');
    console.log('%cType resetWeights() in console to reset weights for displayed champions.', 'font-size:1em;background: #222; color: #fff;');
    console.log("\n\n")

    function getWeightOf(name) { return TEMP.championWeights[Object.values(TEMP.championList).find(x => x.name.toLowerCase() == name).key].weight }

    

    // --- Utility (pure JS, no external deps) ---
    const el = id => document.getElementById(id);
    const champImg = el('champImg');
    const wordWrap = el('word');
    const input = el('input');
    const hintBtn = el('hint');
    const guessBtn = el('guess');
    const nextBtn = el('next');
    const status = el('status');

    // config checkboxes
    const enableSkins = el('enableSkins');
    const onlyUseCentered = el('onlyUseCentered');
    const randomHints = el('randomHints');
    const clearStatsBtn = el('clearStats');


    const TEMP = {
        championList: [],
        guesses: {
            firstTry: [],
            secondTry: [],
            thirdTry: [],
            moreThanThree: [],
            skipped: [],
            total: 0
        },
        championWeights: {}
    }


    function resetWeights() {
        TEMP.championWeights = {};
        console.log("Weights reset.");
    }


    /* ---------- Helpers ---------- */

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function ensureWeightFor(champ) {
        const k = String(champ.key);
        if (!TEMP.championWeights[k]) {
            TEMP.championWeights[k] = {
            key: champ.key,
            weight: 1.0,       // initial neutral weight
            timesShown: 0,
            timesSolved: 0,
            timesSkipped: 0,
            lastPicked: 0
            };
        }
        return TEMP.championWeights[k];
    }


    function saveWeights() {
        localStorage.setItem('championWeights', JSON.stringify(TEMP.championWeights));
    }

    function loadWeights() {
        let loaded = localStorage.getItem('championWeights');
        try {
            const parsed = JSON.parse(loaded);
            if (parsed && typeof parsed === 'object') {
                TEMP.championWeights = parsed;
            }
        } catch (e) {
            console.warn('Failed to load champion weights:', e);
        }
    }

    
    /* ---------- editChampionWeight ----------
    Call this AFTER a round finishes for `current` (the champion object),
    using the global `revealed` array (Array<boolean>) that contains which
    letters were revealed at the moment of finish (true = revealed).
    */
    function editChampionWeight(current, isSkipped = false) {
        if (!current) return;
        const key = String(current.key);
        const w = ensureWeightFor(current);

        // increment seen counter
        w.timesShown = (w.timesShown || 0) + 1;

        // compute letter reveal ratio (letters revealed / total letters)
        const name = current.name || '';
        let totalLetters = 0, revealedLetters = 0;
        for (let i = 0; i < name.length; i++) {
            if (isLetter(name[i])) {
            totalLetters++;
            if (Array.isArray(window.revealed) && window.revealed[i]) revealedLetters++;
            }
        }
        const revealRatio = totalLetters > 0 ? (revealedLetters / totalLetters) : 0;

        // determine attempt category based on TEMP.guesses arrays
        const inArray = (arr) => Array.isArray(arr) && arr.some(x => String(x) === key);
        let categoryScore = 0; // negative = easy, positive = hard

        let revealedLettersCount = revealed.filter(x => x === true).length
        let revealedLettersPercentage = revealedLettersCount / revealed.length

        if (revealedLettersPercentage === 0) categoryScore -= 1.2;
        if (revealedLettersPercentage < 0.33) categoryScore -= 0.2;
        if (revealedLettersPercentage < 0.67) categoryScore += 2;
        if (revealedLettersPercentage >= 0.67) categoryScore += 4;
        if(revealedLettersPercentage === 1) categoryScore += 10;
        if (isSkipped) {
            categoryScore += 2.5; // heavier boost for skipped ones
            w.timesSkipped = (w.timesSkipped || 0) + 1;
        }

        // difficulty component from revealRatio: more reveals => harder
        // scale: revealRatio 0.0 ->  -0.5 (very easy), 0.5 -> 0, 1.0 -> +1.0 (very hard)
        const revealComponent = (revealRatio - 0.5) * 2.0;

        // frequency decay: if champ was shown many times and solved often, decrease weight slowly
        const repeatFactor = Math.log10((w.timesShown || 1) + 1); // grows slowly with timesShown

        // solved bonus (if found in easy buckets)
        const solvedCount = (w.timesSolved || 0);
        const solvedPenalty = solvedCount * 0.12; // more solved -> slightly reduce weight

        // combine into a delta
        let delta = 0.6 * categoryScore + 0.9 * revealComponent - solvedPenalty;
        // normalize by repeat factor to avoid exploding weights for frequent champs
        delta = delta / clamp(repeatFactor, 1, 5);

        // apply to weight with smoothing
        const rawNewWeight = clamp(w.weight + delta, 0.1, 10);
        // smooth: keep some inertia (70% old, 30% new)
        w.weight = clamp(w.weight * 0.7 + rawNewWeight * 0.3, 0.05, 12);

        // update solved counter if guessed in easy categories
        if (!isSkipped && categoryScore < 0) {
            w.timesSolved = (w.timesSolved || 0) + 1;
        }

        // record last updated time
        w.lastUpdated = Date.now();

        saveWeights();

        // debug (optional)
        // console.debug('editChampionWeight', key, { revealRatio, categoryScore, delta, newWeight: w.weight, timesShown: w.timesShown });
        return w.weight;
    }

    /* ---------- getRandomChampion ----------
    Returns a champion object from TEMP.championList chosen by weighted random.
    Updates lastPicked and timesShown in TEMP.championWeights but DOES NOT modify guesses.
    */
    function getRandomChampion() {
        if (!Array.isArray(TEMP.championList) || TEMP.championList.length === 0) return null;

        // ensure all champions have weight entries
        for (const c of TEMP.championList) ensureWeightFor(c);

        // build weighted list (optionally you can filter out champions here)
        const entries = TEMP.championList.map(c => {
            const meta = TEMP.championWeights[String(c.key)] || { weight: 1.0 };
            // ensure weight is positive
            const weight = clamp(Number(meta.weight) || 1.0, 0.01, 1000);
            return { champ: c, weight };
        });

        // compute total and pick
        const totalWeight = entries.reduce((s, e) => s + e.weight, 0);
        if (totalWeight <= 0) {
            // fallback uniform random
            return entries[Math.floor(Math.random() * entries.length)].champ;
        }
        let r = Math.random() * totalWeight;
        for (const e of entries) {
            r -= e.weight;
            if (r <= 0) {
            // mark pick metadata
            const meta = ensureWeightFor(e.champ);
            meta.lastPicked = Date.now();
            // do NOT increment timesShown here if you prefer to increment only after round ends;
            // but we increment so the weight algorithm can use timesShown when next editing.
            meta.timesShown = (meta.timesShown || 0) + 1;
            return e.champ;
            }
        }

        // fallback
        const last = entries[entries.length - 1];
        const meta = ensureWeightFor(last.champ);
        meta.lastPicked = Date.now();
        meta.timesShown = (meta.timesShown || 0) + 1;
        return last.champ;
    }







    function saveStats() {
        localStorage.setItem('guesses', JSON.stringify(TEMP.guesses));
    }
    function loadStats() {
        let loaded = JSON.parse(localStorage.getItem('guesses'))
        if (loaded) {
            TEMP.guesses.firstTry = loaded.firstTry || [];
            TEMP.guesses.secondTry = loaded.secondTry || [];
            TEMP.guesses.thirdTry = loaded.thirdTry || [];
            TEMP.guesses.moreThanThree = loaded.moreThanThree || [];
            TEMP.guesses.skipped = loaded.skipped || [];
            TEMP.guesses.total = loaded.total || 0;
        }
        saveStats()
    }
    function clearStats() {
        TEMP.guesses = {
            firstTry: [],
            secondTry: [],
            thirdTry: [],
            moreThanThree: [],
            skipped: [],
            total: 0
        }
        saveStats()
        updateGuessesDisplay()
    }
    loadStats()
    loadWeights()
    updateGuessesDisplay()
    

    clearStatsBtn.addEventListener('click', () => {
        let confirmation = confirm("Are you sure you want to clear all stats?");
        if (confirmation) {
            clearStats();
        }
    })

    function addToGuesses(champion, _revealedLetters) {

        console.log("addToGuesses", champion, _revealedLetters)

        let revealedLetters = _revealedLetters.filter(r => r == true).length
        // Check with revealed chars array if its first try, second, third or more.
        if (revealedLetters === 0) {
            TEMP.guesses.firstTry.push(champion);
        } else if (revealedLetters === 1) {
            TEMP.guesses.secondTry.push(champion);
        } else if (revealedLetters === 2) {
            TEMP.guesses.thirdTry.push(champion);
        } else {
            TEMP.guesses.moreThanThree.push(champion);
        }
        TEMP.guesses.total++;
        saveStats()

        updateGuessesDisplay()
    }
    function addToGuessesSkipped(champion) {
        TEMP.guesses.skipped.push(champion);
        TEMP.guesses.total++;
        saveStats()
        updateGuessesDisplay()
    }

    function updateGuessesDisplay() {
        // Calculate percentages
        const { firstTry, secondTry, thirdTry, moreThanThree, skipped, total } = TEMP.guesses;

        const calcPercent = (arr) => total > 0 ? Math.round((arr.length / total) * 100) : 0;

        document.querySelector('.guess_firsttry').textContent    = `1th ${calcPercent(firstTry)}% (${firstTry.length})`;
        document.querySelector('.guess_secondtry').textContent   = `2th ${calcPercent(secondTry)}% (${secondTry.length})`;
        document.querySelector('.guess_thirdtry').textContent    = `3rd ${calcPercent(thirdTry)}% (${thirdTry.length})`;
        document.querySelector('.guess_morethan3').textContent   = `3+ ${calcPercent(moreThanThree)}% (${moreThanThree.length})`;
        document.querySelector('.guess_skipped').textContent     = `Skipped: ${calcPercent(skipped)}% (${skipped.length})`;
        document.querySelector('.total-count').textContent       = total;
    }

    updateGuessesDisplay()


    async function getAllSkinsOfChampion(champion) {
        // configuration
        const base = 'https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.18.1/img/champion';
        const timeoutMs = 500;
        const maxSkins = 100;

        // helper: fetch HEAD with timeout (returns Response or throws)
        async function headWithTimeout(url, ms) {
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), ms);
            try {
            const res = await fetch(url, { method: 'HEAD', signal: controller.signal });
            return res;
            } finally {
            clearTimeout(timer);
            }
        }

        // build promises 1..maxSkins
        const promises = Array.from({ length: maxSkins }, (_, idx) => {
            const i = idx + 1;
            const centeredUrl = `${base}/centered/${champion.id}_${i}.jpg`;

            return (async () => {
            try {
                const res = await headWithTimeout(centeredUrl, timeoutMs);
                if (res && res.status === 200) return i;
            } catch (err) {
                // timeout or network error -> treat as missing
            }
            return null;
            })();
        });

        const results = await Promise.all(promises);
        const list = results.filter(x => x != null).map(Number);

        console.log(`Found skins for ${champion.name}: ${list}`);

        return list.map(i => {

            if(onlyUseCentered.checked == true) {
                return `${base}/centered/${champion.id}_${i}.jpg`
            } else {
                return [
                    `${base}/centered/${champion.id}_${i}.jpg`,
                    /* `${base}/splash/${champion.id}_${i}.jpg`, */
                    `${base}/tiles/${champion.id}_${i}.jpg`,
                    `${base}/loading/${champion.id}_${i}.jpg`
                ]
            }
        }).flat();
    }



    async function getRandomChampionImage(key) {
        let champ = TEMP.championList.find(c => c.key === key)

        let list = [
            `https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.18.1/img/champion/centered/${champ.id}_0.jpg`,
        ]
        if(onlyUseCentered.checked == false) {
            list = list.concat([
                /* `https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.18.1/img/champion/splash/${champ.id}_0.jpg`, */
                `https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.18.1/img/champion/tiles/${champ.id}_0.jpg`,
                `https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.18.1/img/champion/loading/${champ.id}_0.jpg`
            ])
        }


        if(enableSkins.checked == false) {
            return list
        }

        let allSkins = await getAllSkinsOfChampion(champ)
        
        return list.concat(allSkins)
        
    }

    async function refreshChampionList() {
        let championsJSON = (await (await fetch("https://leagueoflegends.game.cdn.pog-group.com/ddragon/versions/15.2.1/15.2.1/data/fr_FR/champion.json")).json()).data
        
        let list = Object.values(championsJSON).map(champion => {
            return {
                id: champion.id,
                name: champion.name,
                key: champion.key,
                imageUrl: async () => {
                    let images = await getRandomChampionImage(champion.key)
                    return images[Math.floor(Math.random() * images.length)]
                }
            }
        })

        TEMP.championList = list
    }

    refreshChampionList().then(() => {
         loadRandom();
    })

    function getPossibleChampions() {

    }

    // Helpers
    const isLetter = ch => !!ch && /\p{L}/u.test(ch);
    const sanitize = s => s?.normalize('NFKD').replace(/[\u0300-\u036f]/g, '').toLowerCase().replace(/[^a-z0-9]/g, '');

    // State
    let current = null;   // { imageUrl, name, position, key } from getRandomChampion()
    let revealed = [];    // boolean per character

    // Guard: host must provide getRandomChampion()
    function hostOk() {
      return typeof window.getRandomChampion === 'function';
    }

    function setStatus(text, kind = 'info') {
      status.textContent = text || '';
      status.style.color = kind === 'err' ? '#ff8b8b' : kind === 'ok' ? '#8ef7b0' : '';
    }

    // Render the word as tiles: underscores for hidden letters, show spaces/punct
    function renderWord(full = false) {
        if(full) {
            for (let i = 0; i < revealed.length; i++) revealed[i] = true;
        }
      wordWrap.innerHTML = '';
      if (!current) return;
      for (let i = 0; i < current.name.length; i++) {
        const ch = current.name[i];
        const tile = document.createElement('div');
        tile.className = 'char';
        if (!isLetter(ch)) {
          tile.classList.add('space');
          tile.textContent = ch;
        } else {
          tile.textContent = revealed[i] ? ch.toUpperCase() : '_';
        }
        wordWrap.appendChild(tile);
      }
    }

    // Pick random hidden letter and reveal it
    function revealLetter() {
        console.log("revealLetter")
      if (!current) return false;
      const hidden = [];
      for (let i = 0; i < current.name.length; i++) {
        if (isLetter(current.name[i]) && !revealed[i]) hidden.push(i);
      }
      if (!hidden.length) return false;
      let idx;
      if (randomHints.checked) {
        idx = hidden[Math.floor(Math.random() * hidden.length)];
      } else {
        idx = hidden.shift();
      }
      revealed[idx] = true;
      // tiny animation
      const tile = wordWrap.children[idx];
      if (tile) {
        tile.textContent = current.name[idx].toUpperCase();
        tile.classList.add('reveal');
        setTimeout(() => tile.classList.remove('reveal'), 220);
      } else {
        renderWord();
      }
      return true;
    }

    // Check guess
    function checkGuess() {
        console.log("checkGuess", current, JSON.stringify(revealed))
      if (!current) return;
      const guess = sanitize(input.value || '');
      const target = sanitize(current.name || '');
      if (!guess) { setStatus('Type something first.', 'err'); input.classList.add('shake'); setTimeout(()=>input.classList.remove('shake'),260); return; }
      if (guess === target) {
        // reveal all
        setStatus(`Nice — it's ${current.name}!`, 'ok');
        editChampionWeight(current);
        addToGuesses(current, revealed);
        renderWord(true);
        return true
      } else {
        setStatus('Nope — try again.', 'err');
        input.classList.add('shake');
        setTimeout(()=>input.classList.remove('shake'),260);
        return false
      }
    }

    // Load random champion from host fn. If missing, show friendly warning and disable UI.
    async function loadRandom() {
      if (!hostOk()) {
        champImg.src = '';
        champImg.alt = 'No getRandomChampion() provided';
        wordWrap.innerHTML = '';
        input.disabled = true;
        hintBtn.disabled = true;
        guessBtn.disabled = true;
        nextBtn.disabled = true;
        setStatus('Host must provide window.getRandomChampion() — UI disabled.', 'err');
        return;
      }

        nextBtn.disabled = true;

        
      champImg.src = "/assets/loading-logo-white.png"

      try {
        const ch = window.getRandomChampion();
        current = ch;
      } catch (err) {
        console.error(err);
        setStatus('Error calling getRandomChampion() — check console.', 'err');
        return;
      }

      // prepare reveal flags (non-letters revealed by default)
      console.log("loadRandom, clear revealed")
      revealed = [];
      for (const c of current.name) revealed.push(!isLetter(c));

      // set image and UI
      champImg.src = (await current.imageUrl()) || '';
      champImg.alt = current.name || 'Champion image';
      renderWord();
      input.value = '';
      input.disabled = false;
      hintBtn.disabled = false;
      guessBtn.disabled = false;
      nextBtn.disabled = false;
      setStatus('Type the champion name and press Guess (or Enter).', 'info');
      input.focus();
    }

    // Events
    hintBtn.addEventListener('click', () => {
      if (!current) return;
      const ok = revealLetter();
      if (!ok) setStatus('All letters revealed already.', 'info');
      else setStatus('A letter was revealed.', 'info');
    });

    guessBtn.addEventListener('click', checkGuess);
    nextBtn.addEventListener('click', () => {
        if(lastGuessCorrect == false) {
            editChampionWeight(current, true);
            addToGuessesSkipped(current);
        }
        lastGuessCorrect = false;
        loadRandom();
    });

    let lastGuessCorrect = false;
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();

            // If no text, do nothing
            if (!input.value) return;

            console.log('Enter:', lastGuessCorrect);

            if (lastGuessCorrect) {
                // second Enter → go to next
                lastGuessCorrect = false;
                loadRandom();
                return;
            }

            const correct = checkGuess(); // should return true if guess is correct
            if(!correct) { revealLetter() }
            lastGuessCorrect = !!correct;
        }

        if (e.key === 'Escape') {
            input.value = '';
        }
    });

    // Init
   

    // Note: getPossibleChampions() is intentionally not used here (per request).
    // If you want autocomplete, wire input events to window.getPossibleChampions.
  </script>
</body>
</html>
